#include <iostream>
#include <fstream>
#include <algorithm>
#include <filesystem>
#include <cassert>
#include <vector>
#include <QRandomGenerator>

#include "Planet.hpp"
#include "Plate.hpp"

#define PI 3.14159265358979323846

Planet::Planet (QOpenGLContext *context)
{
    glContext = context;
    glFunctions = glContext->extraFunctions();
    init ();
    initGLSL ();
    mesh.setContext(context);
}

Planet::~Planet ()
{
    plates.clear();
    mesh.clear();
    one_ring.clear();
}

void Planet::init ()
{
    planetCreated = false;
    needInitBuffers = true;
    program = new QOpenGLShaderProgram();
    this->plateNum = 5;
    this->radius = 6370;
    this->elems = 6000;
}

void Planet::initGLSL ()
{
    glFunctions->glEnable (GL_LIGHT0);
    glFunctions->glEnable (GL_LIGHT1);
    glFunctions->glEnable (GL_LIGHTING);
    glFunctions->glEnable (GL_COLOR_MATERIAL);
    glFunctions->glEnable (GL_BLEND);
    glFunctions->glEnable (GL_TEXTURE_2D);
    glFunctions->glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glEnable ( GL_DEBUG_OUTPUT);
    glFunctions->glDebugMessageCallback (Planet::MessageCallback, 0);

    std::filesystem::path fs = std::filesystem::current_path ();
    std::string path = fs.string () + "/GLSL/shaders/";
    QString  vShaderPath = QString::fromStdString(path + "planet.vert");
    QString  fShaderPath = QString::fromStdString(path + "planet.frag");
    if(!program->addShaderFromSourceFile(QOpenGLShader::Vertex,vShaderPath))
    {
        std::cerr<<program->log().toStdString()<<std::endl;
        std::cerr<<"Couldn't add VERTEX shader"<<std::endl;
    }
    if(!program->addShaderFromSourceFile(QOpenGLShader::Fragment,fShaderPath))
    {
        std::cerr<<program->log().toStdString()<<std::endl;
        std::cerr<<"Couldn't add FRAGMENT shader"<<std::endl;
    }

    if(!program->link())
    {
        std::cerr<<program->log().toStdString()<<std::endl;
        std::cerr<<"Error linking program"<<std::endl;
    }
    program->bind();
    programID = program->programId();
}

void Planet::initPlanet ()
{
    makeSphere (this->radius);
    triangulate();
    makePlates ();
    initElevations();

    planetCreated = true;
}

void Planet::makeSphere (float radius)
{
    std::cout<<"Making the points of the sphere..."<<std::endl;
    // Calc The Vertices
    mesh.vertices.resize(elems);
    pos.clear();
    pos.resize(elems);

    double goldenRatio = (1 + pow(5,0.5))/2;

    for (long i = 0; i < elems; ++i)
    {
        double theta = 2 * PI * i / goldenRatio;
        double phi = acosf(1 - 2 * (i+0.5f) / elems);
        double x = cosf(theta)*sinf(phi), y=sinf(theta)*sinf(phi), z=cosf(phi);

        QVector3D position = QVector3D (x * radius, y * radius, z * radius) ;
        double squareLength = position.x()*position.x() + position.y()*position.y() + position.z()*position.z(); ;
        double length = sqrt(squareLength);
        QVector3D normal = QVector3D(position.x()/length,position.y()/length,position.z()/length);
        pos[i]=position;
        mesh.vertices[i].pos=position;
        mesh.vertices[i].normals=normal;
    }

    std::cout<<"Done!"<<std::endl;
}


void Planet::triangulate()
{
    std::cout<<"triangulation started..."<<std::endl;
    Point_set points;
    for(const QVector3D &po: pos)
        points.insert(Point(po.x(),po.y(),po.z()));

    typedef std::array<std::size_t, 3> Facet; // Triple of indices
    std::vector<Facet> facets;
    // The function is called using directly the points raw iterators
    CGAL::advancing_front_surface_reconstruction(points.points().begin(),
      points.points().end(),
      std::back_inserter(facets));

    std::cout << facets.size ()
    << " facet(s) generated by reconstruction." << std::endl;
    for(size_t i = 0; i<facets.size(); ++i)
    {
        for(size_t j = 0; j<3; ++j)
            mesh.indices.push_back(facets[i][j]);
    }
    std::cout<<"triangulation finished!"<<std::endl;
}

void collect_one_ring (QVector<QVector3D> const & i_vertices,
    QVector< unsigned int > const & i_triangles,
    QVector<QVector<unsigned int> > & o_one_ring) {
    o_one_ring.clear();
    o_one_ring.resize(i_vertices.size());
    size_t i, j, y, size=i_triangles.size();
    for(i = 0; i<size; i+=3)
    {
        for(j = 0; j<3; ++j) //sommet courant
        {
            for(y = 0; y<3 ;++y) // sommets voisins
            {
                if(j!=y)
                {
                    if(std::find(o_one_ring.begin(), o_one_ring.end(),
                        o_one_ring[i_triangles[i]]) != o_one_ring.end()){
                        o_one_ring[i_triangles[i+j]].push_back(i_triangles[i+y]);
                    }
                }
            }
        }
    }
}

void Planet::makePlates ()
{
    std::cout<<"Segmentation started..."<<std::endl;
    collect_one_ring(pos,mesh.indices,one_ring);
    one_ring.shrink_to_fit();

    plates.clear ();
    plates.resize (plateNum);

    QRandomGenerator prng;
    prng.seed(time(nullptr));
    std::set<unsigned int> tmp_init;
    std::vector<QVector3D> colors(plateNum);
    QVector<QVector<unsigned int>> last_ids;
    last_ids.resize(plateNum);

    for(QVector3D &c : colors)
        c = QVector3D(prng.generateDouble()*1,prng.generateDouble()*1,prng.generateDouble()*1);

    plates[0].type=OCEANIC;
    plates[1].type=CONTINENTAL;
    for(unsigned short i = 2; i < plateNum; ++i)
        plates[i].type = prng.generateDouble() > 0.5 ? OCEANIC : CONTINENTAL;

    for(unsigned short i = 0; i < plateNum; ++i)
    {
        unsigned int first_point_of_plate = prng.bounded((unsigned int)mesh.vertices.size()-1);
        while(std::find(tmp_init.begin(), tmp_init.end(), first_point_of_plate) != tmp_init.end())
        { first_point_of_plate = prng.bounded((unsigned int)mesh.vertices.size()-1); }
        tmp_init.insert(first_point_of_plate);

        mesh.vertices[first_point_of_plate].color = colors[i];
        plates[i].points.push_back(first_point_of_plate);
        last_ids[i] = one_ring[first_point_of_plate];
    }

    QVector<QVector<unsigned int>> next_ids;
    next_ids.resize(plateNum);

    while(mesh.vertices.size() != (int)tmp_init.size())
    {
        for(unsigned short i = 0; i<plateNum; ++i)
        {
            while(!last_ids[i].empty())
            {
                unsigned int current_vertex = last_ids[i].back();
                last_ids[i].pop_back();
                QVector<unsigned int> neighbours = one_ring[current_vertex];
                for(long n = 0; n < neighbours.size(); ++n)
                {
                    if(!tmp_init.contains(neighbours[n]))
                    {
                        tmp_init.insert(neighbours[n]);
                        plates[i].points.push_back(neighbours[n]);
                        mesh.vertices[neighbours[n]].color=colors[i];
                        next_ids[i].push_back(neighbours[n]);
                    }
                }
            }
            last_ids[i] = next_ids[i];
            next_ids[i].clear();
        }
    }
    std::cout<<"Segmentation finished!"<<std::endl;
}

void Planet::initElevations()
{

}

void Planet::drawPlanet(const qglviewer::Camera *camera)
{

    float pMatrix[16];
    float mvMatrix[16];
    camera->getProjectionMatrix (pMatrix);
    camera->getModelViewMatrix (mvMatrix);
    float lightColor[3] = {1,0.9,0.8};
    program->bind();
     /*shader.setUniformValue(shader.uniformLocation("proj_matrix"),QMatrix4x4(pMatrix));
     shader.setUniformValue(shader.uniformLocation("mv_matrix"),QMatrix4x4(mvMatrix));
     shader.setUniformValue(shader.uniformLocation("lightColor"), lightColor);
     shader.setUniformValue(shader.uniformLocation("viewPos"), camPos);
     shader.setUniformValue(shader.uniformLocation("lightPos"), camPos);
     shader.setUniformValue(shader.uniformLocation("lighting"), int(false));*/

     glFunctions->glUniformMatrix4fv (
             glFunctions->glGetUniformLocation (programID, "proj_matrix"), 1,
             GL_FALSE,
             pMatrix);
     glFunctions->glUniformMatrix4fv (
             glFunctions->glGetUniformLocation (programID, "mv_matrix"), 1,
             GL_FALSE,
             mvMatrix);

     glFunctions->glUniform3fv(
             glFunctions->glGetUniformLocation(programID, "viewPos"), 1,
             camera->position()
             );

     glFunctions->glUniform3fv(
             glFunctions->glGetUniformLocation(programID, "lightPos"), 1,
             camera->position()
             );

     glFunctions->glUniform3fv(
             glFunctions->glGetUniformLocation(programID, "lightColor"), 1,
             lightColor
             );

   glFunctions->glUniform1i(
             glFunctions->glGetUniformLocation(programID, "lighting"),
             (int)false
             );

    mesh.Draw(program);
    program->release();
}

void Planet::draw (const qglviewer::Camera *camera)
{
	if (!planetCreated)
		return;

    if(needInitBuffers && planetCreated){
        mesh.setupMesh(program);
        needInitBuffers = false;
    } else {
        drawPlanet(camera);
    }
}

void Planet::clear ()
{
	if (planetCreated)
    {
        plates.clear();
        mesh.clear();
        one_ring.clear();

		planetCreated = false;
        needInitBuffers = true;
	}
}

void Planet::save () const
{
/*	std::string filename = "planet.obj";
	std::ofstream ostream;
	ostream.precision (4);

	ostream.open (filename, std::ios_base::out);
	ostream << "o planet" << std::endl;
    for (size_t i = 0; i < mesh.vertices.size (); ++i)
	{
        ostream << "v " << std::fixed << mesh.vertices[i].pos.x () << " "
            << std::fixed << mesh.vertices[i].pos.y () << " " << std::fixed
            << mesh.vertices[i].pos.z () << std::endl;
	}

    for (size_t i = 0; i < mesh.vertices.size (); ++i)
	{
        ostream << "vn " << mesh.vertices[i].normal.x () << " "
            << mesh.vertices[i].normal.y () << " " << mesh.vertices[i].normal.z ()
			<< std::endl;
    }

    for (size_t i = 0; i < mesh.indices.size (); i += 3)
    {
        ostream << "f " << mesh.indices[i] << " " << mesh.indices[i + 1] << " "
            << mesh.indices[i + 2] << std::endl;
	}
	ostream.close ();

    std::cout << "Wrote to file " << filename << std::endl;*/
}

void Planet::saveOFF () const
{
    /*std::string filename = "planet.off";
	std::ofstream ostream;
	ostream.precision (4);

	ostream.open (filename, std::ios_base::out);

	ostream << "OFF " << std::endl;
    ostream << (mesh.vertices.size ()) << " " << mesh.indices.size () << " 0"
		<< std::endl;

    for (size_t i = 0; i < mesh.vertices.size (); ++i)
	{
        ostream << mesh.vertices[i].pos.x () << " " << mesh.vertices[i].pos.y () << " "
            << mesh.vertices[i].pos.z () << std::endl;
	}

    for (unsigned int t = 0; t < mesh.indices.size (); t += 3)
	{
        ostream << "3 " << (mesh.indices[t]) << " " << (mesh.indices[t + 1]) << " "
            << (mesh.indices[t + 2]) << std::endl;
	}

	ostream.close ();

    std::cout << "Wrote to file " << filename << std::endl;*/
}

void Planet::setOceanicThickness (double _t)
{
  plateParams.oceanicThickness = _t;
  std::cout << "Oceanic thickness: " << this->plateParams.oceanicThickness
    << std::endl;
}

void Planet::setOceanicElevation (double _e)
{
  plateParams.oceanicEleavation = _e;
  std::cout << "Oceanic elevation: " << this->plateParams.oceanicEleavation
    << std::endl;
}

void Planet::setContinentalThickness (double _t)
{
  plateParams.continentalThickness = _t;
  std::cout << "Continental thickness: "
    << this->plateParams.continentalThickness << std::endl;
}

void Planet::setContinentalElevation (double _e)
{
  plateParams.continentalElevation = _e;
  std::cout << "Continental elevation: "
    << this->plateParams.continentalElevation << std::endl;
}

void Planet::setPlateNumber (int _plateNum)
{
  this->plateNum = _plateNum;

  std::cout << "planet plate number: " << this->plateNum << std::endl;
}

void Planet::setRadius (double _r)
{
  this->radius = _r;

  std::cout << "planet radius set to " << this->radius << std::endl;
}

double Planet::getRadius() const
{
  return this->radius;
}

void Planet::setElems (int _elems)
{
  this->elems = _elems;

  std::cout << "planet elems set to " << this->elems << std::endl;
}

